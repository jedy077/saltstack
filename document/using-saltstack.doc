* TOP file
관리적 측면에서 모든 시스템/device/application은 그룹과 role 이 있다. 

이러한 그룹과 롤은 같은 형태의 작업을 진행하게 된다. 

여기서 Top 파일은 이러한 그룹 및 역할을 나누어 해야 할 일들을 명시해 둔 SLS 이다. 
즉 Salt에서는 네트워크상의 머신 그룹과 이러한 머신에 적용해야 하는 구성 역할 간의 매핑이 포함된 파일을 top 파일이라고 합니다.


** Top File은 3개으 구성 요소가 있따. 
1. Environment : base , prod, dev 등 evironment 에 적용해야 할 state file set이 구분되어 진다. 
2. Target : state 을 적용할 group/개별 minion target 이다. 
3. State file : Target에 적용될 state file 들이다. 
example for:
base : 			# Environment
  'web*':		# target
    - apache		# state file name. 

좀더 자세히
Enviroment : 디렉토리 계승인데 , top file 및 state file set을 포함하는 디렉토리 계층이다. 

싱글 환경일 경우, file_roots 에  only base 환경만 정의 되어 진다.

file_roots:
  base:
    /srv/salt/

다음은 단지 싱글 설정이 포함된 TOP.SLS 파일이다. 
/srv/salt/top.sls
  '*':
    - core
    - edit 

*** Multiple Enviroment
Minion System을 분류하여 환경을 만들어 놓은 것이라 볼수 있다. 
이때 분류한 환경에 따라 File_roots 를 구성한다. 

file_roots
  dev:
    /srv/salt/dev
  qa:
    /srv/salt/qa
  prod
    /srv/salt/prod
 
위의 예는 3개의 환경에 대한 root file 경로(top.sls 및 state file이 들어 있는 경로)가 설정 되어 진다.

top file
dev:
  'webserver*':
    - webserver
  'db*':
    - db

qa:
  'webserver*':
    - webserver
  'db*':
    - db
prod:
  'webserver*':
    - webserver
  'db*':
    - db

file root 가 정의된 각 환경에 top.sls 파일을 저장(따로환경에 맞게 저장해도됨)
위의 의미는 모두 각 환경에서 target 이 webserver* , db* 으로 호스트네임을 가지는 서버에 webserver.sls 와 db.sls 를 적용하라는 말이다. 

top 파일 말고 CLI(saltenv) 를 이용하여 해당 Enviroment 에 적용되는 sls group을 지정할 수 있다. 
salt '*' state.apply saltenv='prod'
salt '*' state.highsate saltenv='prod'

***고급 MINION TARGET ( ADVANCED MINION TARGETTING)

base:
  'minion 1':
    - match: glob
    - foo
The available match types which can be set for a target expression in the top file are:

Match Type

Description

glob

Full minion ID or glob expression to match multiple minions (e.g. minion123 or minion*)

pcre

Perl-compatible regular expression (PCRE) matching a minion ID (e.g. web[0-3].domain.com)

grain

Match a grain, optionally using globbing (e.g. kernel:Linux or kernel:*BSD)

grain_pcre

Match a grain using PCRE (e.g. kernel:(Free|Open)BSD)

list

Comma-separated list of minions (e.g. minion1,minion2,minion3)

pillar

Pillar match, optionally using globbing (e.g. role:webserver or role:web*)

pillar_pcre

Pillar match using PCRE (e.g. role:web(server|proxy)

pillar_exact

Pillar match with no globbing or PCRE (e.g. role:webserver)

ipcidr

Subnet or IP address (e.g. 172.17.0.0/16 or 10.2.9.80)

data

Match values kept in the minion's datastore (created using the data execution module)

range

Range cluster

compound

Complex expression combining multiple match types (see here)

nodegroup

Pre-defined compound expressions in the master config file (see here)

아래 예제를 잘 파악하자 .. 이렇게 top file을 복잡/정교 하게 나타낼 수 있다. 

base:
  'nag1' or 'G@role:monitoring':
    - nagios.server

  '*':
    - ldap-client
    - networking
    - salt.minion

  'salt-master':
    - salt-master

  '^(memcache|web).(qa|prod).loc$':
    - match:pcre
    - nagios.mon.web
    - apache.server

  'os:ubunto':
    - match: grain
    - repos.ubuntu

  'os:(RedHat|CentOS)':
    - match: grain_pcre
    - repo.epel

  'foo,bar,baz':
    - match: list
    - database

  'somekey:abc':
    - match:pillar
    - xyz



*** Top file compile 방법
top file 은 highstate 이 실행 될때, 해당 evnironment 에 대응되는 file_roots 에 있는 top파일이 실행된다. 그런데 만약 환경을 지정하지 않는다면 어떻게 될까?
이럴 경우 minion 은 모든 top file을 기본 디렉토리에서 검색을 해서 확인 되는 top file의 내용을 merge 시키고 그 뒤 모두 적용을 한다. 

이러한 경우 우리가 의도하지 않은 결과가 나타날수도 있다. 

이런 경우를 대비하여 - top_file_merge_strategy: same , state_top_saltenv: base 를 지정하여 사용할 수 있따. 

가장 단순한 방법은 file_roots 에 base directory를 하나 생성하고 하나의 top file을 통해서 운영하는 것이 가장 효과적일 수 있다. (일반적인방법)

만약 Minion이 no-evieorment 일때 comfile 되는 방법은

state_top_saltenv

top_file_merging_strategy

env_order

default_top

위에 내용을 따른다. 


TOP FILE COMPILATION EXAMPLE

/etc/salt/master
file_roots:
  base:
    - /srv/salt/base
  dev:
    - /srv/salt/dev
  qa:
    - /srv/salt/qa


/srv/salt/base/top.sls
base:
  '*':
    - base1
dev:
  '*':
    - dev1
qa:
  '*':
    - qa1


/srv/salt/dev/top.sls
base:
  'minion1':
    - base2
dev:
  'minion2':
    - dev2
qa:
  '*':
    - qa1
    - qa2

SCENARIO 1 - DEV ENVIRONMENT SPECIFIED
In this scenario, the highstate was either invoked with saltenv=dev or the minion has environment: dev set in the minion config file. The result will be that only the dev2 SLS from the dev environment will be part of the highstate, and it will be applied to minion2, while minion1 will have no states applied to it.

If the base environment were specified, the result would be that only the base1 SLS from the base environment would be part of the highstate, and it would be applied to all minions.

If the qa environment were specified, the highstate would exit with an error.

SCENARIO 2 - NO ENVIRONMENT SPECIFIED, TOP_FILE_MERGING_STRATEGY IS "MERGE"
In this scenario, assuming that the base environment's top file was evaluated first, the base1, dev1, and qa1 states would be applied to all minions. If, for instance, the qa environment is not defined in /srv/salt/base/top.sls, then because there is no top file for the qa environment, no states from the qa environment would be applied.

SCENARIO 3 - NO ENVIRONMENT SPECIFIED, TOP_FILE_MERGING_STRATEGY IS "SAME"
Changed in version 2016.11.0: In prior versions, "same" did not quite work as described below (see here). This has now been corrected. It was decided that changing something like top file handling in a point release had the potential to unexpectedly impact users' top files too much, and it would be better to make this correction in a feature release.

In this scenario, base1 from the base environment is applied to all minions. Additionally, dev2 from the dev environment is applied to minion2.

If default_top is unset (or set to base, which happens to be the default), then qa1 from the qa environment will be applied to all minions. If default_top were set to dev, then both qa1 and qa2 from the qa environment would be applied to all minions.

SCENARIO 4 - NO ENVIRONMENT SPECIFIED, TOP_FILE_MERGING_STRATEGY IS "MERGE_ALL"
New in version 2016.11.0.

In this scenario, all configured states in all top files are applied. From the base environment, base1 would be applied to all minions, with base2 being applied only to minion1. From the dev environment, dev1 would be applied to all minions, with dev2 being applied only to minion2. Finally, from the qa environment, both the qa1 and qa2 states will be applied to all minions. Note that the qa1 states would not be applied twice, even though qa1 appears twice.


** SLS template variable refrece

{% for file in salt['cmd.run']('ls -l /opt/to_remove').splitlines() %}
/opt/to_remove/{{ file }}:
  file.absent
{% endfor %}

python에서 splitlines() 함수는 출력이 있는 결과에 개행문자 (\r \n) 과 같이 포함이 되어 있는 경우 이 부분을 하나씩 나눠, 나눈 결과값을 list [] 형태로 반환한다. 

file.absent : salt state file 모듈중 하나로 해당 디렉토리에 file 및 directory 가 존재할 경우 삭제한다. ( 항상 해당 디렉토리에 내용이 없어야 한다.)


opts template
{{ opts['cachedir'] }}

opts는 미니언의 configration 내용을 template 한다.  opts 는 dictionary type 이다. 


pillar  : pillar 역시 dictionary type 으로 아래와 같이 직접 접근 할 수 있다. 
{{ pillar['key'] }}

salt 에서는 pillre 를 piller.get 을 이용하여 직접 접근하는 것이 좋다. 
{{ salt['piller.get']('key','failover_value') }}
{{ salt['piller.get']('staff:more:deeper') }}

grains: minion 에 directly connect and get info ( grains is dictionary type)
{{ grains['os'] }}
{{ salt['grains.get']('os') }}

saltenv 는 각 evnrioment 환경의 sls 을 모은다.수집하여 사용할 수있다. 
{{ saltenv }}

sls 는 sls 안에서만 참조 변수로 사용가능하다. 
{{ sls }}

slspath 는 sls 파일의 경로를 반환한다. file_roots
{{ slspath }}

sls_path 는slspath 와 동일하다 다만 경로 표시를 / 대신 _ 를 사용한다.
{{ sls_path }}

slsdotpath 역시 slspath 와 동일하다 다만 / 대신 .을 사용한다. 
{{ slsdotpath }}

slscolonpath 역시 slspath와 동일하다 다만 / 대신 :을 사용한다. 
{{ slscolonpath }}

tplpath sls file 의 전체 경로를 말한다. (보통 CACHEDIRECTORY 의 복사본 경로 - 사용하지 말자)
{{ tplpath }}

tplfile - file_roots 기준으로 처리되고 있는 SLS TEMPLATE FILE 상대 경로

tpldir file_roots 에서 상대적이 sls 파일의 경로 ( slspath와 비슷)

my-file:
  file.managed:
    source: salt://{{ tpldir }}/files/my-template
tpldir 는 보통 salt 를 사용할대 상대적인 경로에 많이 사용한다. 

tlpdot 경로를 .으로 표현

{{ tpldot }}


** state module **
'state module'은 실제 salt에서실제 실행 혹은 관리해야 하는 맵핑된 컨포넌트 들이다. 

state module은 작성하기 쉽다.  아래 봐라
/etc/salt/master:
  file.managed:
    - user: root
    - group: root
    - mode: 644
    - source: salt://salt/manager

vs
etc_salt_master:
  file.manager:
    - name: /etc/salt/master
    - user: root
    - group: root
    - mode: 644
    - source://salt/manager


BEST PRACTICES
A well-written state function will follow these steps
referce site : https://github.com/saltstack/salt/tree/master/salt/states


def myfunc():
  ret = {"name": name, "result": False, "change"|{} , "comment:":""}

  if foo and bar:
    ret["comment"] = "Only one of foo and bar is permitted"
    return ret

result = __salt__["modname.check"](name) --> 상태를 확인. --> 참조 사이트 https://docs.saltproject.io/en/latest/ref/modules/index.html#writing-execution-modules


def myfunc():
  if result:
    ret["result"] = True
    ret["comment"] = "{0} is already installed".format(name)
    return ret






